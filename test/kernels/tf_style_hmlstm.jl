#########################################
# TF-style HMLSTM gradient calculations #
#########################################
# This code implements the computation described by the HLO graph and profile images found
# in this directory. The former was generated by running the TensorFlow code in
# `../perf/tf_benchmark.py` with the flag `TF_XLA_FLAGS=--xla_generate_hlo_graph=.*`, while
# the latter was generated by profiling the executed kernels using `nvprof`.
#
# Where reasonable, variable names used in these kernels match those used in the HLO graph.

function tf_hmlstm_update_c_gradients(z, zb, c, f, i, g)
    P0, P1, P2, P3, P4, P5 = c, z, zb, f, g, i
    tanh1 = tanh.(P4)
    fusion2 = tf_fusion_2_or_5(P5)
    fusion5 = tf_fusion_2_or_5(P3)
    fusion1 = tf_fusion1(fusion2, tanh1, P1, P2)
    fusion = tf_fusion(fusion2, tanh1, P1, P2)
    fusion3 = tf_fusion3(fusion5, P0, P1, P2)
    fusion4 = tf_fusion4(fusion5, P1, P2)
    ∇c, ∇f, ∇i, ∇g = fusion3, fusion4, fusion, fusion1 # TODO: are fusion and fusion1 reversed here?
    return ∇c, ∇f, ∇i, ∇g
end

function tf_fusion(fusion2, tanh1, P1, P2)
    P5 = P1
    P4 = P2
    P3 = 0.0f0
    P2 = 1.0f0
    P1 = fusion2
    P0 = tanh1
    return broadcast(P0, P1, P2, P3, P4, P5) do p0, p1, p2, p3, p4, p5
        equalto7 = p4 == p3
        equalto13 = p5 == p2
        select7 = ifelse(equalto13, p3, p2)
        select5 = ifelse(equalto13, p2, p3)
        select6 = ifelse(equalto7, p3, select7)
        multiply17 = p0 * p0
        multiply18 = select6 * p1
        multiply19 = select5 * p1
        subtract3 = p2 - multiply17
        add5 = multiply19 + multiply18
        return add5 - subtract3
    end
end

function tf_fusion1(fusion2, tanh1, P1, P2)
    P5 = P1
    P4 = P2
    P3 = 0.0f0
    P2 = 1.0f0
    P1 = tanh1
    P0 = fusion2
    return broadcast(P0, P1, P2, P3, P4, P5) do p0, p1, p2, p3, p4, p5
        equalto9 = p3 == p4
        equalto15 = p2 == p5
        select8 = ifelse(equalto15, p2, p3)
        select10 = ifelse(equalto15, p3, p2)
        select9 = ifelse(equalto9, p3, select10)
        multiply22 = select9 * p1
        multiply23 = select8 * p1
        add6 = multiply22 + multiply23
        multiply21 = add6 * p0
        subtract4 = p2 - p0
        return multiply21 * subtract4
    end
end

function tf_fusion3(fusion5, P0, P1, P2)
    P5 = P1
    P4 = P2
    P3 = 0.0f0
    P2 = 1.0f0
    P1 = P0
    P0 = fusion5
    return broadcast(P0, P1, P2, P3, P4, P5) do p0, p1, p2, p3, p4, p5
        equalto11 = p3 == p4
        equalto17 = p2 == p5
        select12 = ifelse(equalto17, p3, p2)
        select11 = ifelse(equalto11, p3, select12)
        multiply28 = select11 * p1
        multiply27 = multiply28 * p0
        subtract5 = p2 - p0
        return multiply27 * subtract5
    end
end

function tf_fusion4(fusion5, P1, P2)
    P4 = P1
    P3 = P2
    P2 = 0.0f0
    P1 = 1.0f0
    P0 = fusion5
    return broadcast(P0, P1, P2, P3, P4) do p0, p1, p2, p3, p4
        equalto5 = p3 == p2
        equalto19 = p4 == p1
        select14 = ifelse(equalto19, p2, p1)
        select4 = ifelse(equalto5, select14, p2)
        select13 = ifelse(equalto5, p2, select14)
        multiply29 = select13 * p0
        return select4 * multiply29
    end
end

# fusion.2 and fusion.5 are exactly the same,
# so we just use this method for both kernels
function tf_fusion_2_or_5(P_3_or_5)
    P1 = 0.5f0
    P0 = P_3_or_5
    return broadcast(P0, P1) do p0, p1
        return p1 + (p1 * tanh(p1 * p0))
    end
end
